/**
 * This file was automatically generated by nexus-prisma@0.3.7
 * Do not make changes to this file directly
 */

import { core } from 'nexus'
import { GraphQLResolveInfo } from 'graphql'
import * as prisma from '../prisma-client'

declare global {
  interface NexusPrismaGen extends NexusPrismaTypes {}
}

export interface NexusPrismaTypes {
  objectTypes: {
    fields: {
      Query: QueryObject
      User: UserObject
      Token: TokenObject
      UserConnection: UserConnectionObject
      PageInfo: PageInfoObject
      UserEdge: UserEdgeObject
      AggregateUser: AggregateUserObject
      TokenConnection: TokenConnectionObject
      TokenEdge: TokenEdgeObject
      AggregateToken: AggregateTokenObject
      Mutation: MutationObject
      BatchPayload: BatchPayloadObject
      Subscription: SubscriptionObject
      UserSubscriptionPayload: UserSubscriptionPayloadObject
      UserPreviousValues: UserPreviousValuesObject
      TokenSubscriptionPayload: TokenSubscriptionPayloadObject
      TokenPreviousValues: TokenPreviousValuesObject
    }
    fieldsDetails: {
      Query: QueryFieldDetails
      User: UserFieldDetails
      Token: TokenFieldDetails
      UserConnection: UserConnectionFieldDetails
      PageInfo: PageInfoFieldDetails
      UserEdge: UserEdgeFieldDetails
      AggregateUser: AggregateUserFieldDetails
      TokenConnection: TokenConnectionFieldDetails
      TokenEdge: TokenEdgeFieldDetails
      AggregateToken: AggregateTokenFieldDetails
      Mutation: MutationFieldDetails
      BatchPayload: BatchPayloadFieldDetails
      Subscription: SubscriptionFieldDetails
      UserSubscriptionPayload: UserSubscriptionPayloadFieldDetails
      UserPreviousValues: UserPreviousValuesFieldDetails
      TokenSubscriptionPayload: TokenSubscriptionPayloadFieldDetails
      TokenPreviousValues: TokenPreviousValuesFieldDetails
    }
  }
  inputTypes: {
    fields: {
      UserWhereUniqueInput: UserWhereUniqueInputInputObject
      TokenWhereInput: TokenWhereInputInputObject
      UserWhereInput: UserWhereInputInputObject
      TokenWhereUniqueInput: TokenWhereUniqueInputInputObject
      UserCreateInput: UserCreateInputInputObject
      TokenCreateManyWithoutUserInput: TokenCreateManyWithoutUserInputInputObject
      TokenCreateWithoutUserInput: TokenCreateWithoutUserInputInputObject
      UserUpdateInput: UserUpdateInputInputObject
      TokenUpdateManyWithoutUserInput: TokenUpdateManyWithoutUserInputInputObject
      TokenUpdateWithWhereUniqueWithoutUserInput: TokenUpdateWithWhereUniqueWithoutUserInputInputObject
      TokenUpdateWithoutUserDataInput: TokenUpdateWithoutUserDataInputInputObject
      TokenUpsertWithWhereUniqueWithoutUserInput: TokenUpsertWithWhereUniqueWithoutUserInputInputObject
      TokenScalarWhereInput: TokenScalarWhereInputInputObject
      TokenUpdateManyWithWhereNestedInput: TokenUpdateManyWithWhereNestedInputInputObject
      TokenUpdateManyDataInput: TokenUpdateManyDataInputInputObject
      UserUpdateManyMutationInput: UserUpdateManyMutationInputInputObject
      TokenCreateInput: TokenCreateInputInputObject
      UserCreateOneWithoutRefreshTokensInput: UserCreateOneWithoutRefreshTokensInputInputObject
      UserCreateWithoutRefreshTokensInput: UserCreateWithoutRefreshTokensInputInputObject
      TokenUpdateInput: TokenUpdateInputInputObject
      UserUpdateOneRequiredWithoutRefreshTokensInput: UserUpdateOneRequiredWithoutRefreshTokensInputInputObject
      UserUpdateWithoutRefreshTokensDataInput: UserUpdateWithoutRefreshTokensDataInputInputObject
      UserUpsertWithoutRefreshTokensInput: UserUpsertWithoutRefreshTokensInputInputObject
      TokenUpdateManyMutationInput: TokenUpdateManyMutationInputInputObject
      UserSubscriptionWhereInput: UserSubscriptionWhereInputInputObject
      TokenSubscriptionWhereInput: TokenSubscriptionWhereInputInputObject
    }
  }
  enumTypes: {
    Role: RoleValues,
    TokenOrderByInput: TokenOrderByInputValues,
    UserOrderByInput: UserOrderByInputValues,
    MutationType: MutationTypeValues,
  }
}

// Types for Query

type QueryObject =
  | QueryFields
  | { name: 'user', args?: QueryUserArgs[] | false, alias?: string  } 
  | { name: 'users', args?: QueryUsersArgs[] | false, alias?: string  } 
  | { name: 'usersConnection', args?: QueryUsersConnectionArgs[] | false, alias?: string  } 
  | { name: 'token', args?: QueryTokenArgs[] | false, alias?: string  } 
  | { name: 'tokens', args?: QueryTokensArgs[] | false, alias?: string  } 
  | { name: 'tokensConnection', args?: QueryTokensConnectionArgs[] | false, alias?: string  } 

type QueryFields =
  | 'user'
  | 'users'
  | 'usersConnection'
  | 'token'
  | 'tokens'
  | 'tokensConnection'


type QueryUserArgs =
  | 'where'
type QueryUsersArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryUsersConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryTokenArgs =
  | 'where'
type QueryTokensArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryTokensConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface QueryFieldDetails {
  user: {
    type: 'User'
    args: Record<QueryUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: UserWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  users: {
    type: 'User'
    args: Record<QueryUsersArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: UserWhereInput | null, orderBy?: prisma.UserOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User[]> | prisma.User[]
  }
  usersConnection: {
    type: 'UserConnection'
    args: Record<QueryUsersConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: UserWhereInput | null, orderBy?: prisma.UserOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserConnection> | prisma.UserConnection
  }
  token: {
    type: 'Token'
    args: Record<QueryTokenArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: TokenWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Token | null> | prisma.Token | null
  }
  tokens: {
    type: 'Token'
    args: Record<QueryTokensArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: TokenWhereInput | null, orderBy?: prisma.TokenOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Token[]> | prisma.Token[]
  }
  tokensConnection: {
    type: 'TokenConnection'
    args: Record<QueryTokensConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: TokenWhereInput | null, orderBy?: prisma.TokenOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TokenConnection> | prisma.TokenConnection
  }
}
  

// Types for User

type UserObject =
  | UserFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'userName', args?: [] | false, alias?: string  } 
  | { name: 'email', args?: [] | false, alias?: string  } 
  | { name: 'password', args?: [] | false, alias?: string  } 
  | { name: 'role', args?: [] | false, alias?: string  } 
  | { name: 'refreshTokens', args?: UserRefreshTokensArgs[] | false, alias?: string  } 

type UserFields =
  | 'id'
  | 'userName'
  | 'email'
  | 'password'
  | 'role'
  | 'refreshTokens'


type UserRefreshTokensArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface UserFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  userName: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  email: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  password: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  role: {
    type: 'Role'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"User">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Role> | prisma.Role
  }
  refreshTokens: {
    type: 'Token'
    args: Record<UserRefreshTokensArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"User">,
      args: { where?: TokenWhereInput | null, orderBy?: prisma.TokenOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Token[]> | prisma.Token[]
  }
}
  

// Types for Token

type TokenObject =
  | TokenFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'token', args?: [] | false, alias?: string  } 
  | { name: 'loginId', args?: [] | false, alias?: string  } 
  | { name: 'user', args?: [] | false, alias?: string  } 

type TokenFields =
  | 'id'
  | 'token'
  | 'loginId'
  | 'user'



  

export interface TokenFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  token: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  loginId: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  user: {
    type: 'User'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Token">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
}
  

// Types for UserConnection

type UserConnectionObject =
  | UserConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type UserConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface UserConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'UserEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"UserConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserEdge[]> | prisma.UserEdge[]
  }
  aggregate: {
    type: 'AggregateUser'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateUser> | prisma.AggregateUser
  }
}
  

// Types for PageInfo

type PageInfoObject =
  | PageInfoFields
  | { name: 'hasNextPage', args?: [] | false, alias?: string  } 
  | { name: 'hasPreviousPage', args?: [] | false, alias?: string  } 
  | { name: 'startCursor', args?: [] | false, alias?: string  } 
  | { name: 'endCursor', args?: [] | false, alias?: string  } 

type PageInfoFields =
  | 'hasNextPage'
  | 'hasPreviousPage'
  | 'startCursor'
  | 'endCursor'



  

export interface PageInfoFieldDetails {
  hasNextPage: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  hasPreviousPage: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  startCursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  endCursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  

// Types for UserEdge

type UserEdgeObject =
  | UserEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type UserEdgeFields =
  | 'node'
  | 'cursor'



  

export interface UserEdgeFieldDetails {
  node: {
    type: 'User'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateUser

type AggregateUserObject =
  | AggregateUserFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateUserFields =
  | 'count'



  

export interface AggregateUserFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for TokenConnection

type TokenConnectionObject =
  | TokenConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type TokenConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface TokenConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TokenConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'TokenEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"TokenConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TokenEdge[]> | prisma.TokenEdge[]
  }
  aggregate: {
    type: 'AggregateToken'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TokenConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateToken> | prisma.AggregateToken
  }
}
  

// Types for TokenEdge

type TokenEdgeObject =
  | TokenEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type TokenEdgeFields =
  | 'node'
  | 'cursor'



  

export interface TokenEdgeFieldDetails {
  node: {
    type: 'Token'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TokenEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Token> | prisma.Token
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateToken

type AggregateTokenObject =
  | AggregateTokenFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateTokenFields =
  | 'count'



  

export interface AggregateTokenFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Mutation

type MutationObject =
  | MutationFields
  | { name: 'createUser', args?: MutationCreateUserArgs[] | false, alias?: string  } 
  | { name: 'updateUser', args?: MutationUpdateUserArgs[] | false, alias?: string  } 
  | { name: 'updateManyUsers', args?: MutationUpdateManyUsersArgs[] | false, alias?: string  } 
  | { name: 'upsertUser', args?: MutationUpsertUserArgs[] | false, alias?: string  } 
  | { name: 'deleteUser', args?: MutationDeleteUserArgs[] | false, alias?: string  } 
  | { name: 'deleteManyUsers', args?: MutationDeleteManyUsersArgs[] | false, alias?: string  } 
  | { name: 'createToken', args?: MutationCreateTokenArgs[] | false, alias?: string  } 
  | { name: 'updateToken', args?: MutationUpdateTokenArgs[] | false, alias?: string  } 
  | { name: 'updateManyTokens', args?: MutationUpdateManyTokensArgs[] | false, alias?: string  } 
  | { name: 'upsertToken', args?: MutationUpsertTokenArgs[] | false, alias?: string  } 
  | { name: 'deleteToken', args?: MutationDeleteTokenArgs[] | false, alias?: string  } 
  | { name: 'deleteManyTokens', args?: MutationDeleteManyTokensArgs[] | false, alias?: string  } 

type MutationFields =
  | 'createUser'
  | 'updateUser'
  | 'updateManyUsers'
  | 'upsertUser'
  | 'deleteUser'
  | 'deleteManyUsers'
  | 'createToken'
  | 'updateToken'
  | 'updateManyTokens'
  | 'upsertToken'
  | 'deleteToken'
  | 'deleteManyTokens'


type MutationCreateUserArgs =
  | 'data'
type MutationUpdateUserArgs =
  | 'data'
  | 'where'
type MutationUpdateManyUsersArgs =
  | 'data'
  | 'where'
type MutationUpsertUserArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteUserArgs =
  | 'where'
type MutationDeleteManyUsersArgs =
  | 'where'
type MutationCreateTokenArgs =
  | 'data'
type MutationUpdateTokenArgs =
  | 'data'
  | 'where'
type MutationUpdateManyTokensArgs =
  | 'data'
  | 'where'
type MutationUpsertTokenArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteTokenArgs =
  | 'where'
type MutationDeleteManyTokensArgs =
  | 'where'
  

export interface MutationFieldDetails {
  createUser: {
    type: 'User'
    args: Record<MutationCreateUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: UserCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
  updateUser: {
    type: 'User'
    args: Record<MutationUpdateUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: UserUpdateInput, where: UserWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  updateManyUsers: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyUsersArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: UserUpdateManyMutationInput, where?: UserWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertUser: {
    type: 'User'
    args: Record<MutationUpsertUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: UserWhereUniqueInput, create: UserCreateInput, update: UserUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
  deleteUser: {
    type: 'User'
    args: Record<MutationDeleteUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: UserWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  deleteManyUsers: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyUsersArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: UserWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createToken: {
    type: 'Token'
    args: Record<MutationCreateTokenArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: TokenCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Token> | prisma.Token
  }
  updateToken: {
    type: 'Token'
    args: Record<MutationUpdateTokenArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: TokenUpdateInput, where: TokenWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Token | null> | prisma.Token | null
  }
  updateManyTokens: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyTokensArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: TokenUpdateManyMutationInput, where?: TokenWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertToken: {
    type: 'Token'
    args: Record<MutationUpsertTokenArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: TokenWhereUniqueInput, create: TokenCreateInput, update: TokenUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Token> | prisma.Token
  }
  deleteToken: {
    type: 'Token'
    args: Record<MutationDeleteTokenArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: TokenWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Token | null> | prisma.Token | null
  }
  deleteManyTokens: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyTokensArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: TokenWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
}
  

// Types for BatchPayload

type BatchPayloadObject =
  | BatchPayloadFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type BatchPayloadFields =
  | 'count'



  

export interface BatchPayloadFieldDetails {
  count: {
    type: 'Long'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Subscription

type SubscriptionObject =
  | SubscriptionFields
  | { name: 'user', args?: SubscriptionUserArgs[] | false, alias?: string  } 
  | { name: 'token', args?: SubscriptionTokenArgs[] | false, alias?: string  } 

type SubscriptionFields =
  | 'user'
  | 'token'


type SubscriptionUserArgs =
  | 'where'
type SubscriptionTokenArgs =
  | 'where'
  

export interface SubscriptionFieldDetails {
  user: {
    type: 'UserSubscriptionPayload'
    args: Record<SubscriptionUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: UserSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserSubscriptionPayload | null> | prisma.UserSubscriptionPayload | null
  }
  token: {
    type: 'TokenSubscriptionPayload'
    args: Record<SubscriptionTokenArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: TokenSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TokenSubscriptionPayload | null> | prisma.TokenSubscriptionPayload | null
  }
}
  

// Types for UserSubscriptionPayload

type UserSubscriptionPayloadObject =
  | UserSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type UserSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface UserSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'User'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"UserSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'UserPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"UserSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserPreviousValues | null> | prisma.UserPreviousValues | null
  }
}
  

// Types for UserPreviousValues

type UserPreviousValuesObject =
  | UserPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'userName', args?: [] | false, alias?: string  } 
  | { name: 'email', args?: [] | false, alias?: string  } 
  | { name: 'password', args?: [] | false, alias?: string  } 
  | { name: 'role', args?: [] | false, alias?: string  } 

type UserPreviousValuesFields =
  | 'id'
  | 'userName'
  | 'email'
  | 'password'
  | 'role'



  

export interface UserPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  userName: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  email: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  password: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  role: {
    type: 'Role'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserPreviousValues">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Role> | prisma.Role
  }
}
  

// Types for TokenSubscriptionPayload

type TokenSubscriptionPayloadObject =
  | TokenSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type TokenSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface TokenSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TokenSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Token'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"TokenSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Token | null> | prisma.Token | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'TokenPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"TokenSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TokenPreviousValues | null> | prisma.TokenPreviousValues | null
  }
}
  

// Types for TokenPreviousValues

type TokenPreviousValuesObject =
  | TokenPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'token', args?: [] | false, alias?: string  } 
  | { name: 'loginId', args?: [] | false, alias?: string  } 

type TokenPreviousValuesFields =
  | 'id'
  | 'token'
  | 'loginId'



  

export interface TokenPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  token: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  loginId: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  


export interface UserWhereUniqueInput {
  id?: string | null
  userName?: string | null
  email?: string | null
}
export type UserWhereUniqueInputInputObject =
  | Extract<keyof UserWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'userName', alias?: string  } 
  | { name: 'email', alias?: string  } 
  
export interface TokenWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  token?: string | null
  token_not?: string | null
  token_in?: string[]
  token_not_in?: string[]
  token_lt?: string | null
  token_lte?: string | null
  token_gt?: string | null
  token_gte?: string | null
  token_contains?: string | null
  token_not_contains?: string | null
  token_starts_with?: string | null
  token_not_starts_with?: string | null
  token_ends_with?: string | null
  token_not_ends_with?: string | null
  loginId?: string | null
  loginId_not?: string | null
  loginId_in?: string[]
  loginId_not_in?: string[]
  loginId_lt?: string | null
  loginId_lte?: string | null
  loginId_gt?: string | null
  loginId_gte?: string | null
  loginId_contains?: string | null
  loginId_not_contains?: string | null
  loginId_starts_with?: string | null
  loginId_not_starts_with?: string | null
  loginId_ends_with?: string | null
  loginId_not_ends_with?: string | null
  user?: UserWhereInput | null
  AND?: TokenWhereInput[]
}
export type TokenWhereInputInputObject =
  | Extract<keyof TokenWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'token', alias?: string  } 
  | { name: 'token_not', alias?: string  } 
  | { name: 'token_in', alias?: string  } 
  | { name: 'token_not_in', alias?: string  } 
  | { name: 'token_lt', alias?: string  } 
  | { name: 'token_lte', alias?: string  } 
  | { name: 'token_gt', alias?: string  } 
  | { name: 'token_gte', alias?: string  } 
  | { name: 'token_contains', alias?: string  } 
  | { name: 'token_not_contains', alias?: string  } 
  | { name: 'token_starts_with', alias?: string  } 
  | { name: 'token_not_starts_with', alias?: string  } 
  | { name: 'token_ends_with', alias?: string  } 
  | { name: 'token_not_ends_with', alias?: string  } 
  | { name: 'loginId', alias?: string  } 
  | { name: 'loginId_not', alias?: string  } 
  | { name: 'loginId_in', alias?: string  } 
  | { name: 'loginId_not_in', alias?: string  } 
  | { name: 'loginId_lt', alias?: string  } 
  | { name: 'loginId_lte', alias?: string  } 
  | { name: 'loginId_gt', alias?: string  } 
  | { name: 'loginId_gte', alias?: string  } 
  | { name: 'loginId_contains', alias?: string  } 
  | { name: 'loginId_not_contains', alias?: string  } 
  | { name: 'loginId_starts_with', alias?: string  } 
  | { name: 'loginId_not_starts_with', alias?: string  } 
  | { name: 'loginId_ends_with', alias?: string  } 
  | { name: 'loginId_not_ends_with', alias?: string  } 
  | { name: 'user', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface UserWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  userName?: string | null
  userName_not?: string | null
  userName_in?: string[]
  userName_not_in?: string[]
  userName_lt?: string | null
  userName_lte?: string | null
  userName_gt?: string | null
  userName_gte?: string | null
  userName_contains?: string | null
  userName_not_contains?: string | null
  userName_starts_with?: string | null
  userName_not_starts_with?: string | null
  userName_ends_with?: string | null
  userName_not_ends_with?: string | null
  email?: string | null
  email_not?: string | null
  email_in?: string[]
  email_not_in?: string[]
  email_lt?: string | null
  email_lte?: string | null
  email_gt?: string | null
  email_gte?: string | null
  email_contains?: string | null
  email_not_contains?: string | null
  email_starts_with?: string | null
  email_not_starts_with?: string | null
  email_ends_with?: string | null
  email_not_ends_with?: string | null
  password?: string | null
  password_not?: string | null
  password_in?: string[]
  password_not_in?: string[]
  password_lt?: string | null
  password_lte?: string | null
  password_gt?: string | null
  password_gte?: string | null
  password_contains?: string | null
  password_not_contains?: string | null
  password_starts_with?: string | null
  password_not_starts_with?: string | null
  password_ends_with?: string | null
  password_not_ends_with?: string | null
  role?: prisma.Role | null
  role_not?: prisma.Role | null
  role_in?: prisma.Role[]
  role_not_in?: prisma.Role[]
  refreshTokens_some?: TokenWhereInput | null
  AND?: UserWhereInput[]
}
export type UserWhereInputInputObject =
  | Extract<keyof UserWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'userName', alias?: string  } 
  | { name: 'userName_not', alias?: string  } 
  | { name: 'userName_in', alias?: string  } 
  | { name: 'userName_not_in', alias?: string  } 
  | { name: 'userName_lt', alias?: string  } 
  | { name: 'userName_lte', alias?: string  } 
  | { name: 'userName_gt', alias?: string  } 
  | { name: 'userName_gte', alias?: string  } 
  | { name: 'userName_contains', alias?: string  } 
  | { name: 'userName_not_contains', alias?: string  } 
  | { name: 'userName_starts_with', alias?: string  } 
  | { name: 'userName_not_starts_with', alias?: string  } 
  | { name: 'userName_ends_with', alias?: string  } 
  | { name: 'userName_not_ends_with', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'email_not', alias?: string  } 
  | { name: 'email_in', alias?: string  } 
  | { name: 'email_not_in', alias?: string  } 
  | { name: 'email_lt', alias?: string  } 
  | { name: 'email_lte', alias?: string  } 
  | { name: 'email_gt', alias?: string  } 
  | { name: 'email_gte', alias?: string  } 
  | { name: 'email_contains', alias?: string  } 
  | { name: 'email_not_contains', alias?: string  } 
  | { name: 'email_starts_with', alias?: string  } 
  | { name: 'email_not_starts_with', alias?: string  } 
  | { name: 'email_ends_with', alias?: string  } 
  | { name: 'email_not_ends_with', alias?: string  } 
  | { name: 'password', alias?: string  } 
  | { name: 'password_not', alias?: string  } 
  | { name: 'password_in', alias?: string  } 
  | { name: 'password_not_in', alias?: string  } 
  | { name: 'password_lt', alias?: string  } 
  | { name: 'password_lte', alias?: string  } 
  | { name: 'password_gt', alias?: string  } 
  | { name: 'password_gte', alias?: string  } 
  | { name: 'password_contains', alias?: string  } 
  | { name: 'password_not_contains', alias?: string  } 
  | { name: 'password_starts_with', alias?: string  } 
  | { name: 'password_not_starts_with', alias?: string  } 
  | { name: 'password_ends_with', alias?: string  } 
  | { name: 'password_not_ends_with', alias?: string  } 
  | { name: 'role', alias?: string  } 
  | { name: 'role_not', alias?: string  } 
  | { name: 'role_in', alias?: string  } 
  | { name: 'role_not_in', alias?: string  } 
  | { name: 'refreshTokens_some', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface TokenWhereUniqueInput {
  id?: string | null
  token?: string | null
  loginId?: string | null
}
export type TokenWhereUniqueInputInputObject =
  | Extract<keyof TokenWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'token', alias?: string  } 
  | { name: 'loginId', alias?: string  } 
  
export interface UserCreateInput {
  id?: string | null
  userName?: string | null
  email?: string
  password?: string
  role?: prisma.Role
  refreshTokens?: TokenCreateManyWithoutUserInput | null
}
export type UserCreateInputInputObject =
  | Extract<keyof UserCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'userName', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'password', alias?: string  } 
  | { name: 'role', alias?: string  } 
  | { name: 'refreshTokens', alias?: string  } 
  
export interface TokenCreateManyWithoutUserInput {
  create?: TokenCreateWithoutUserInput[]
  connect?: TokenWhereUniqueInput[]
}
export type TokenCreateManyWithoutUserInputInputObject =
  | Extract<keyof TokenCreateManyWithoutUserInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface TokenCreateWithoutUserInput {
  id?: string | null
  token?: string
  loginId?: string
}
export type TokenCreateWithoutUserInputInputObject =
  | Extract<keyof TokenCreateWithoutUserInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'token', alias?: string  } 
  | { name: 'loginId', alias?: string  } 
  
export interface UserUpdateInput {
  userName?: string | null
  email?: string | null
  password?: string | null
  role?: prisma.Role | null
  refreshTokens?: TokenUpdateManyWithoutUserInput | null
}
export type UserUpdateInputInputObject =
  | Extract<keyof UserUpdateInput, string>
  | { name: 'userName', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'password', alias?: string  } 
  | { name: 'role', alias?: string  } 
  | { name: 'refreshTokens', alias?: string  } 
  
export interface TokenUpdateManyWithoutUserInput {
  create?: TokenCreateWithoutUserInput[]
  delete?: TokenWhereUniqueInput[]
  connect?: TokenWhereUniqueInput[]
  set?: TokenWhereUniqueInput[]
  disconnect?: TokenWhereUniqueInput[]
  update?: TokenUpdateWithWhereUniqueWithoutUserInput[]
  upsert?: TokenUpsertWithWhereUniqueWithoutUserInput[]
  deleteMany?: TokenScalarWhereInput[]
  updateMany?: TokenUpdateManyWithWhereNestedInput[]
}
export type TokenUpdateManyWithoutUserInputInputObject =
  | Extract<keyof TokenUpdateManyWithoutUserInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface TokenUpdateWithWhereUniqueWithoutUserInput {
  where?: TokenWhereUniqueInput
  data?: TokenUpdateWithoutUserDataInput
}
export type TokenUpdateWithWhereUniqueWithoutUserInputInputObject =
  | Extract<keyof TokenUpdateWithWhereUniqueWithoutUserInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface TokenUpdateWithoutUserDataInput {
  token?: string | null
  loginId?: string | null
}
export type TokenUpdateWithoutUserDataInputInputObject =
  | Extract<keyof TokenUpdateWithoutUserDataInput, string>
  | { name: 'token', alias?: string  } 
  | { name: 'loginId', alias?: string  } 
  
export interface TokenUpsertWithWhereUniqueWithoutUserInput {
  where?: TokenWhereUniqueInput
  update?: TokenUpdateWithoutUserDataInput
  create?: TokenCreateWithoutUserInput
}
export type TokenUpsertWithWhereUniqueWithoutUserInputInputObject =
  | Extract<keyof TokenUpsertWithWhereUniqueWithoutUserInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface TokenScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  token?: string | null
  token_not?: string | null
  token_in?: string[]
  token_not_in?: string[]
  token_lt?: string | null
  token_lte?: string | null
  token_gt?: string | null
  token_gte?: string | null
  token_contains?: string | null
  token_not_contains?: string | null
  token_starts_with?: string | null
  token_not_starts_with?: string | null
  token_ends_with?: string | null
  token_not_ends_with?: string | null
  loginId?: string | null
  loginId_not?: string | null
  loginId_in?: string[]
  loginId_not_in?: string[]
  loginId_lt?: string | null
  loginId_lte?: string | null
  loginId_gt?: string | null
  loginId_gte?: string | null
  loginId_contains?: string | null
  loginId_not_contains?: string | null
  loginId_starts_with?: string | null
  loginId_not_starts_with?: string | null
  loginId_ends_with?: string | null
  loginId_not_ends_with?: string | null
  AND?: TokenScalarWhereInput[]
  OR?: TokenScalarWhereInput[]
  NOT?: TokenScalarWhereInput[]
}
export type TokenScalarWhereInputInputObject =
  | Extract<keyof TokenScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'token', alias?: string  } 
  | { name: 'token_not', alias?: string  } 
  | { name: 'token_in', alias?: string  } 
  | { name: 'token_not_in', alias?: string  } 
  | { name: 'token_lt', alias?: string  } 
  | { name: 'token_lte', alias?: string  } 
  | { name: 'token_gt', alias?: string  } 
  | { name: 'token_gte', alias?: string  } 
  | { name: 'token_contains', alias?: string  } 
  | { name: 'token_not_contains', alias?: string  } 
  | { name: 'token_starts_with', alias?: string  } 
  | { name: 'token_not_starts_with', alias?: string  } 
  | { name: 'token_ends_with', alias?: string  } 
  | { name: 'token_not_ends_with', alias?: string  } 
  | { name: 'loginId', alias?: string  } 
  | { name: 'loginId_not', alias?: string  } 
  | { name: 'loginId_in', alias?: string  } 
  | { name: 'loginId_not_in', alias?: string  } 
  | { name: 'loginId_lt', alias?: string  } 
  | { name: 'loginId_lte', alias?: string  } 
  | { name: 'loginId_gt', alias?: string  } 
  | { name: 'loginId_gte', alias?: string  } 
  | { name: 'loginId_contains', alias?: string  } 
  | { name: 'loginId_not_contains', alias?: string  } 
  | { name: 'loginId_starts_with', alias?: string  } 
  | { name: 'loginId_not_starts_with', alias?: string  } 
  | { name: 'loginId_ends_with', alias?: string  } 
  | { name: 'loginId_not_ends_with', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface TokenUpdateManyWithWhereNestedInput {
  where?: TokenScalarWhereInput
  data?: TokenUpdateManyDataInput
}
export type TokenUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof TokenUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface TokenUpdateManyDataInput {
  token?: string | null
  loginId?: string | null
}
export type TokenUpdateManyDataInputInputObject =
  | Extract<keyof TokenUpdateManyDataInput, string>
  | { name: 'token', alias?: string  } 
  | { name: 'loginId', alias?: string  } 
  
export interface UserUpdateManyMutationInput {
  userName?: string | null
  email?: string | null
  password?: string | null
  role?: prisma.Role | null
}
export type UserUpdateManyMutationInputInputObject =
  | Extract<keyof UserUpdateManyMutationInput, string>
  | { name: 'userName', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'password', alias?: string  } 
  | { name: 'role', alias?: string  } 
  
export interface TokenCreateInput {
  id?: string | null
  token?: string
  loginId?: string
  user?: UserCreateOneWithoutRefreshTokensInput
}
export type TokenCreateInputInputObject =
  | Extract<keyof TokenCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'token', alias?: string  } 
  | { name: 'loginId', alias?: string  } 
  | { name: 'user', alias?: string  } 
  
export interface UserCreateOneWithoutRefreshTokensInput {
  create?: UserCreateWithoutRefreshTokensInput | null
  connect?: UserWhereUniqueInput | null
}
export type UserCreateOneWithoutRefreshTokensInputInputObject =
  | Extract<keyof UserCreateOneWithoutRefreshTokensInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface UserCreateWithoutRefreshTokensInput {
  id?: string | null
  userName?: string | null
  email?: string
  password?: string
  role?: prisma.Role
}
export type UserCreateWithoutRefreshTokensInputInputObject =
  | Extract<keyof UserCreateWithoutRefreshTokensInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'userName', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'password', alias?: string  } 
  | { name: 'role', alias?: string  } 
  
export interface TokenUpdateInput {
  token?: string | null
  loginId?: string | null
  user?: UserUpdateOneRequiredWithoutRefreshTokensInput | null
}
export type TokenUpdateInputInputObject =
  | Extract<keyof TokenUpdateInput, string>
  | { name: 'token', alias?: string  } 
  | { name: 'loginId', alias?: string  } 
  | { name: 'user', alias?: string  } 
  
export interface UserUpdateOneRequiredWithoutRefreshTokensInput {
  create?: UserCreateWithoutRefreshTokensInput | null
  update?: UserUpdateWithoutRefreshTokensDataInput | null
  upsert?: UserUpsertWithoutRefreshTokensInput | null
  connect?: UserWhereUniqueInput | null
}
export type UserUpdateOneRequiredWithoutRefreshTokensInputInputObject =
  | Extract<keyof UserUpdateOneRequiredWithoutRefreshTokensInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface UserUpdateWithoutRefreshTokensDataInput {
  userName?: string | null
  email?: string | null
  password?: string | null
  role?: prisma.Role | null
}
export type UserUpdateWithoutRefreshTokensDataInputInputObject =
  | Extract<keyof UserUpdateWithoutRefreshTokensDataInput, string>
  | { name: 'userName', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'password', alias?: string  } 
  | { name: 'role', alias?: string  } 
  
export interface UserUpsertWithoutRefreshTokensInput {
  update?: UserUpdateWithoutRefreshTokensDataInput
  create?: UserCreateWithoutRefreshTokensInput
}
export type UserUpsertWithoutRefreshTokensInputInputObject =
  | Extract<keyof UserUpsertWithoutRefreshTokensInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface TokenUpdateManyMutationInput {
  token?: string | null
  loginId?: string | null
}
export type TokenUpdateManyMutationInputInputObject =
  | Extract<keyof TokenUpdateManyMutationInput, string>
  | { name: 'token', alias?: string  } 
  | { name: 'loginId', alias?: string  } 
  
export interface UserSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: UserWhereInput | null
  AND?: UserSubscriptionWhereInput[]
}
export type UserSubscriptionWhereInputInputObject =
  | Extract<keyof UserSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  
export interface TokenSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: TokenWhereInput | null
  AND?: TokenSubscriptionWhereInput[]
}
export type TokenSubscriptionWhereInputInputObject =
  | Extract<keyof TokenSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  

export type RoleValues =
  | 'ADMIN'
  | 'DEFAULT_USER'
  
export type TokenOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'token_ASC'
  | 'token_DESC'
  | 'loginId_ASC'
  | 'loginId_DESC'
  
export type UserOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'userName_ASC'
  | 'userName_DESC'
  | 'email_ASC'
  | 'email_DESC'
  | 'password_ASC'
  | 'password_DESC'
  | 'role_ASC'
  | 'role_DESC'
  
export type MutationTypeValues =
  | 'CREATED'
  | 'UPDATED'
  | 'DELETED'
  
  